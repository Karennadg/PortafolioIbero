{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto Introducci\u00f3n a la mec\u00e1tronica","text":""},{"location":"#nuestro-portafolio-de-actividades","title":"Nuestro Portafolio de Actividades","text":"<p>Introducci\u00f3n a la mec\u00e1tronica Departamento de Ciencias e Ingenier\u00edas | Universidad Iberoamericana Puebla, M\u00e9xico.</p> <p></p> <p>Karen Itzel Najera De Gante</p> <p>Ingenier\u00eda mec\u00e1tronica | karen.najera@iberopuebla.mx</p> <p>Resumen: Soy estudiante de d\u00e9cimo semestre de Ingenier\u00eda Mecatr\u00f3nica, con formaci\u00f3n previa en Ingenier\u00eda Mec\u00e1nica. Mi pasi\u00f3n por los desaf\u00edos y la innovaci\u00f3n me llev\u00f3 a continuar mis estudios en una segunda carrera, con el objetivo de ampliar mis conocimientos y abrir mayores oportunidades en el campo laboral. Durante seis meses trabaj\u00e9 como analista en EDAG Test Lab M\u00e9xico, donde adquir\u00ed experiencia en pruebas y validaciones dentro del sector automotriz. Actualmente, sigo desarrollando mis habilidades en \u00e1reas multidisciplinarias, combinando mec\u00e1nica, electr\u00f3nica y automatizaci\u00f3n para enfrentar retos tecnol\u00f3gicos con una visi\u00f3n integral.</p> <p></p> <p>Tom\u00e1s Toledo Fern\u00e1ndez</p> <p>Ingenier\u00eda mec\u00e1tronica | 202945@iberopuebla.mx</p> <p>Resumen: Soy estudiante de primer semestre de Mecatronica,con estudios previos en el area de f\u00edsicos matem\u00e1ticos.Me inspira la evoluci\u00f3n y la autosuperacion, lo que me permite todos los dias dar lo mejor de mi para llegar a ser una persona que aporte algo a la humanidad.He estudiado en la universidad la salle oaxaca seccion bachillerato donde obtuve demasiodos conocimentos que me han permitido tener conocimiento escencial para mi carrera.Mi meta es concluir mis estudios en la universidad ,buscar una maestria y ser una persona de cambio.</p>"},{"location":"#_1","title":"Documentaci\u00f3n del Proyecto Introducci\u00f3n a la mec\u00e1tronica","text":""},{"location":"PRACTICA1/","title":"\ud83d\udcda Pr\u00e1ctica 1: Temporizador Astable con 555","text":""},{"location":"PRACTICA1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 05/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se dise\u00f1\u00f3 e implement\u00f3 un circuito temporizador en modo astable utilizando el circuito integrado 555. Se calcularon los tiempos de salida en estado alto y bajo, as\u00ed como la frecuencia del tren de pulsos generado. Adem\u00e1s, se analizaron las f\u00f3rmulas que rigen su comportamiento y se utiliz\u00f3 un simulador para validar los resultados obtenidos.</li> </ul>"},{"location":"PRACTICA1/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento del temporizador 555 en modo astable y c\u00f3mo configurar sus tiempos de salida mediante resistencias y capacitores.</li> <li>Espec\u00edficos:</li> <li>Identificar los pines del circuito integrado 555 y su funci\u00f3n en modo astable.</li> <li>Configurar el circuito en un simulador y comprobar el comportamiento de la se\u00f1al generada.</li> <li>Interpretar el diagrama de se\u00f1al de salida en un ciclo completo.</li> </ul>"},{"location":"PRACTICA1/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye: -  C\u00e1lculo de los tiempos de salida (alto y bajo) en funci\u00f3n de R1, R2 y C1.</p> <ul> <li> <p>An\u00e1lisis del comportamiento de un circuito 555 en modo astable.</p> </li> <li> <p>Uso de simulador para observar la se\u00f1al de salida..</p> </li> </ul> <p>No incluye: - Implementaci\u00f3n en protoboard o hardware real. - Programaci\u00f3n de microcontroladores.. - Control de dispositivos externos con la se\u00f1al de salida.</p>"},{"location":"PRACTICA1/#4-resultados","title":"4) Resultados","text":"<p>Durante la realizaci\u00f3n de la pr\u00e1ctica, se dise\u00f1\u00f3 un circuito astable utilizando el temporizador 555 con los siguientes componentes: dos resistencias de 200 k\u03a9 (R1 y R2) y un capacitor de 22 \u00b5F (C1). Estos valores fueron ingresados en un simulador, el cual permiti\u00f3 visualizar tanto la se\u00f1al de salida como los c\u00e1lculos correspondientes al comportamiento temporal del circuito. El simulador arroj\u00f3 un tiempo alto (T\u2081) de aproximadamente 6.0984 segundos, y un tiempo bajo (T\u2082) de 3.0492 segundos, lo que indica que la se\u00f1al permanece m\u00e1s tiempo en estado alto que en estado bajo. La frecuencia del ciclo completo result\u00f3 ser 0.1091 Hz, lo cual representa una se\u00f1al de baja frecuencia, adecuada para aplicaciones donde no se requieren cambios r\u00e1pidos de estado, como en sistemas de parpadeo o temporizadores de larga duraci\u00f3n.</p> <p></p> <p>Al final logramos ver el parpadeo de un led con los valores mostrados, en un circuito armado</p> <p>Video armado</p>"},{"location":"PRACTICA1/#5-conclusiones","title":"5) conclusiones","text":"<p>En conclusi\u00f3n, se comprendi\u00f3 satisfactoriamente el funcionamiento del temporizador 555 en modo astable. Se demostr\u00f3 que es posible controlar el ciclo de trabajo y la frecuencia de la se\u00f1al de salida mediante la elecci\u00f3n adecuada de los valores de R1, R2 y C1. Adem\u00e1s, el uso del simulador permiti\u00f3 validar los c\u00e1lculos te\u00f3ricos, visualizar la forma de onda generada y entender la importancia de cada componente en el circuito.</p> <p>```</p>"},{"location":"PRACTICA2/","title":"\ud83d\udcda Pr\u00e1ctica 2: SP32 (ESP32-S3 Dev)","text":""},{"location":"PRACTICA2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Tom\u00e1s Toledo y Karen Itzel </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 16/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se dise\u00f1aron e implementaron 3 circuitos con arduino diferentes con diferentes resultados pero con el mismo arduino</li> </ul>"},{"location":"PRACTICA2/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: _Comprender algunas de las posibles y mas b\u00e1sicas utilidades del arduino y el como programarlo . Espec\u00edficos: Identificar los c\u00f3digos mas b\u00e1sicos con los que trabaja el arduino. Configurar el arduino y ver como funciona el c\u00f3digo programado.</li> </ul>"},{"location":"PRACTICA2/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye:</p> <p>-Uso de se\u00f1ales bluetooth.</p> <p>-An\u00e1lisis del comportamiento de un ciclo generado por el arduino.</p> <p>-Componentes f\u00edsicos para complementar la practica.</p> <p>No incluye:</p> <p>-Utilizaci\u00f3n del wifi del arduino.</p> <p>-Prueas digitales del funcionamiento.</p>"},{"location":"PRACTICA2/#4-resultados","title":"4) Resultados","text":"<p>Durante la realizaci\u00f3n de la pr\u00e1ctica, se programo un arduino 3 veces con una funci\u00f3n diferente cada vez,en la primera que mandara un parpadeo de un segundo a un led lo cual funciono a la perfecci\u00f3n,en la segunda buscamos que el led se encendiera cada vez que presionabamos un bot\u00f3n y salio exelente , el led se encend\u00ed cada vez que presionjabamos el bot\u00f3n y para terminar hicimos que el led se encendiera cada vez que nos llegara el mensaje on y haciamos que se apagara cuando el arduino recibia el mensaje off. </p> <p></p> <p></p> <p>Al final logramos ver el parpadeo de un led,el encendido y apagado de un led con un bot\u00f3n y el encendido y apagado de un led via bluetooth Video armado</p> <p>Video armado</p> <p>Video armado</p>"},{"location":"PRACTICA2/#5-conclusiones","title":"5) conclusiones","text":"<p>En conclusi\u00f3n, se comprendi\u00f3 satisfactoriamente la manera de programar a un arduino para que nos ayude con diferentes tareas y el como nos puede facilitar ciertos trabajos gracias a todas sus posibles funciones.</p>"},{"location":"PRACTICA3/","title":"\ud83d\udcda Pr\u00e1ctica 3: Control de velocidad de motor DC con ESP32","text":""},{"location":"PRACTICA3/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Tom\u00e1s Toledo y Karen Itzel </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 19/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se desarroll\u00f3 un programa en el ESP32 para controlar la velocidad de un motor de corriente directa (DC) utilizando modulaci\u00f3n por ancho de pulso (PWM). Se configuraron los pines de salida digital y el canal PWM del microcontrolador para variar gradualmente la velocidad del motor en ambas direcciones de giro.</li> </ul>"},{"location":"PRACTICA3/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: _Comprender el control de velocidad de un motor DC mediante se\u00f1ales PWM generadas por el ESP32. Espec\u00edficos: Configurar los pines de salida del ESP32 para controlar la direcci\u00f3n de giro de un motor. Observar el cambio de velocidad en ambas direcciones del giro del motor.</li> </ul>"},{"location":"PRACTICA3/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye:</p> <p>-Programaci\u00f3n en Arduino IDE utilizando el ESP32.</p> <p>-Control de un motor DC mediante salidas digitales y PWM.</p> <p>-Variaci\u00f3n progresiva de la velocidad del motor en ambas direcciones.</p> <p>No incluye:</p> <p>-Control PID o sistemas de regulaci\u00f3n autom\u00e1tica.</p> <p>-Integraci\u00f3n con m\u00f3dulos de comunicaci\u00f3n.</p>"},{"location":"PRACTICA3/#4-codigo","title":"4) Codigo","text":"<pre><code>#define in1 32\n#define in2 33\n#define pwm 25\n\nvoid setup() {\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  ledcAttachChannel(pwm, 1000, 8, 0); // Configuraci\u00f3n del canal PWM\n}\n\nvoid loop() {\n\n  for (int vel = 0; vel &lt; 256; vel++) {\n    ledcWrite(pwm, vel);\n    digitalWrite(in1, 1);\n    digitalWrite(in2, 0);\n    delay(10);\n  }\n\n\n  for (int vel = 256; vel &gt; 0; vel--) {\n    ledcWrite(pwm, vel);\n    digitalWrite(in1, 1);\n    digitalWrite(in2, 0);\n    delay(10);\n  }\n}\n</code></pre>"},{"location":"PRACTICA3/#4-resultados","title":"4) Resultados","text":"<p>El motor incrementa gradualmente su velocidad desde 0 hasta el valor m\u00e1ximo (255) y luego disminuye hasta detenerse. El sentido de giro se mantiene constante, controlado por las se\u00f1ales digitales de los pines in1 y in2.</p> <p>Al final logramos ver el comportamiento controlado del motor</p> <p>Video armado</p>"},{"location":"PRACTICA3/#5-conclusiones","title":"5) conclusiones","text":"<p>Se logr\u00f3 comprender el uso del PWM en el ESP32 para el control de velocidad de un motor DC. El programa permiti\u00f3 visualizar c\u00f3mo la variaci\u00f3n del ciclo de trabajo modifica la potencia entregada al motor, cambiando as\u00ed su velocidad. Esta pr\u00e1ctica constituye la base para el control m\u00e1s avanzado de motores, incluyendo inversi\u00f3n de giro, control de torque y sistemas autom\u00e1ticos</p>"},{"location":"PROYECTO/","title":"\ud83d\udcda Proyecto integrador: Control de veh\u00edculo robotizado mediante Bluetooth y ESP32","text":""},{"location":"PROYECTO/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Tom\u00e1s Toledo y Karen Itzel </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 18/10/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se desarroll\u00f3 un sistema de control para un veh\u00edculo robotizado utilizando un microcontrolador ESP32 con comunicaci\u00f3n Bluetooth. El proyecto permite controlar la direcci\u00f3n y el movimiento del robot a trav\u00e9s de comandos enviados desde una aplicaci\u00f3n m\u00f3vil. El sistema integra el control de un servo para el giro del eje delantero y dos motores DC para las llantas traseras, posibilitando movimientos hacia adelante, atr\u00e1s, izquierda, derecha y alto total.</li> </ul>"},{"location":"PROYECTO/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: _Dise\u00f1ar e implementar un sistema de control inal\u00e1mbrico por Bluetooth utilizando el ESP32 para manejar la direcci\u00f3n y el desplazamiento de un veh\u00edculo robotizado. Espec\u00edficos: Configurar la comunicaci\u00f3n Bluetooth entre el ESP32 y un dispositivo m\u00f3vil. Implementar el control de los motores DC para los diferentes movimientos del veh\u00edculo.</li> </ul>"},{"location":"PROYECTO/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye:</p> <p>-Programaci\u00f3n en Arduino IDE utilizando el ESP32.</p> <p>-Control de un servo y dos motores DC conectados al ESP32.</p> <p>-Control direccional b\u00e1sico: avance, retroceso, giro y detenci\u00f3n.</p> <p>No incluye:</p> <p>-Sensores de distancia o sistemas de detecci\u00f3n de obst\u00e1culos.</p>"},{"location":"PROYECTO/#-comunicacion-wi-fi-o-control-por-internet","title":"-Comunicaci\u00f3n Wi-Fi o control por Internet.","text":""},{"location":"PROYECTO/#4-codigo","title":"4) Codigo","text":"<pre><code>#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n\n#define SERVO_PIN 32  // Pin del servo\n#define pwm 26        // Pin del control de velocidad\n// Controladores del motor de llanta izquierda\n#define in1 33\n#define in2 25\n// Controladores del motor de llanta derecha\n#define in3 27\n#define in4 14\n\nint angulo = 90; // Posici\u00f3n inicial\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"Pancracio2\");  // Nombre Bluetooth visible en la app\n  Serial.println(\"Esperando conexi\u00f3n Bluetooth...\");\n\n  // PWM del ESP32 para controlar el servo\n  ledcAttach(SERVO_PIN, 50, 8);  // Pin, frecuencia 50Hz, resoluci\u00f3n 8 bits\n\n  // Salidas de los motores\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  pinMode(in3, OUTPUT);\n  pinMode(in4, OUTPUT);\n\n  moverServo(angulo);  // Centra el servo al iniciar\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    int msj = SerialBT.read();\n    Serial.println(msj);\n\n    if (msj &gt;= 0 &amp;&amp; msj &lt;= 180) {\n      moverServo(msj);\n\n    } else if (msj == 182) { // Adelante\n      digitalWrite(in1, 1); digitalWrite(in2, 0);\n      digitalWrite(in3, 1); digitalWrite(in4, 0);\n\n    } else if (msj == 183) { // Atr\u00e1s\n      digitalWrite(in1, 0); digitalWrite(in2, 1);\n      digitalWrite(in3, 0); digitalWrite(in4, 1);\n\n    } else if (msj == 184) { // Giro izquierda\n      digitalWrite(in1, 1); digitalWrite(in2, 0);\n      digitalWrite(in3, 0); digitalWrite(in4, 1);\n\n    } else if (msj == 185) { // Giro derecha\n      digitalWrite(in1, 0); digitalWrite(in2, 1);\n      digitalWrite(in3, 1); digitalWrite(in4, 0);\n\n    } else if (msj == 186) { // Alto total\n      digitalWrite(in1, 0); digitalWrite(in2, 0);\n      digitalWrite(in3, 0); digitalWrite(in4, 0);\n    }\n  }\n}\n\n// Conversi\u00f3n de \u00e1ngulo a se\u00f1al PWM\nvoid moverServo(int angulo) {\n  int duty = map(angulo, 0, 180, 13, 26);  // Ajusta si el servo no recorre bien\n  ledcWrite(SERVO_PIN, duty);\n}\n</code></pre>"},{"location":"PROYECTO/#4-resultados","title":"4) Resultados","text":"<p>El sistema respondi\u00f3 correctamente a los comandos enviados desde el dispositivo m\u00f3vil. El servo se movi\u00f3 en un rango de 0\u00b0 a 180\u00b0, permitiendo controlar la direcci\u00f3n del veh\u00edculo. Los motores DC reaccionaron adecuadamente a los comandos para avanzar, retroceder, girar y detenerse. El enlace Bluetooth se mantuvo estable durante toda la prueba, mostrando una comunicaci\u00f3n eficiente entre el ESP32 y el controlador remoto.</p> <p></p> <p>Al final realizar un dise\u00f1o del veh\u00edculo y de la pagna de control que permitiera una correcta conexi\u00f3n entre componentes y codigo</p> <p>Video armado</p>"},{"location":"PROYECTO/#5-conclusiones","title":"5) conclusiones","text":"<p>Se logr\u00f3 implementar exitosamente un sistema de control de veh\u00edculo robotizado utilizando un ESP32 y comunicaci\u00f3n Bluetooth. La pr\u00e1ctica permiti\u00f3 comprender c\u00f3mo se integran servomotores y motores DC dentro de un mismo sistema de control. El uso de comandos num\u00e9ricos simplific\u00f3 la comunicaci\u00f3n, garantizando una respuesta inmediata del veh\u00edculo ante cada orden. Este proyecto constituye la base para desarrollar futuros sistemas aut\u00f3nomos con sensores o control remoto avanzado.</p>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/","title":"\ud83d\udcda Proyecto Final","text":""},{"location":"Proyecto%20base%20que%20se%20estabiliza/#nombre-del-proyecto-ball-and-plate-system","title":"Nombre del proyecto: Ball and Plate system","text":""},{"location":"Proyecto%20base%20que%20se%20estabiliza/#autor","title":"Autor","text":"<ul> <li>Tom\u00e1s Toledo Fern\u00e1ndez</li> </ul>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#asignatura-introduccion-a-la-mecatronica","title":"Asignatura: Introducci\u00f3n a la Mecatronica","text":""},{"location":"Proyecto%20base%20que%20se%20estabiliza/#fecha-5-de-diciembre-del-2025","title":"Fecha: 5 de Diciembre del 2025","text":""},{"location":"Proyecto%20base%20que%20se%20estabiliza/#descripcion","title":"Descripci\u00f3n","text":"<p>En este proyecto final desarrollamos un Ball and Plate System, un mecanismo mecatr\u00f3nico capaz de mantener una pelota equilibrada sobre una plataforma mediante la variaci\u00f3n de \u00e1ngulos en una placa superior.</p> <p>El sistema utiliza cuatro servomotores, los cuales modifican la inclinaci\u00f3n de la placa en los ejes X y Y. A trav\u00e9s del control coordinado de estos servomotores, la plataforma es capaz de moverse en diferentes direcciones para dirigir o estabilizar la pelota en una posici\u00f3n deseada.</p> <p>Este mecanismo es una base importante para sistemas de control avanzados, como plataformas estabilizadoras, robots equilibristas o sistemas de visi\u00f3n con retroalimentaci\u00f3n. El proyecto se encuentra documentado y versionado en GitHub, donde se registran los avances, diagramas y c\u00f3digos implementados.</p>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#objetivos","title":"Objetivos","text":""},{"location":"Proyecto%20base%20que%20se%20estabiliza/#general","title":"General","text":"<p>Dise\u00f1ar y programar un sistema mecatr\u00f3nico de control de inclinaci\u00f3n capaz de mover una plataforma en dos ejes mediante servomotores para lograr el equilibrio din\u00e1mico de una pelota.</p>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#especificos","title":"Especificos","text":"<ul> <li>Implementar la comunicaci\u00f3n y control de 4 servomotores utilizando un microcontrolador (Arduino/ESP32)..  </li> <li>Dise\u00f1ar la estructura mec\u00e1nica para mover la placa superior mediante un sistema articulado. </li> <li>Desarrollar el c\u00f3digo para mover la plataforma en diferentes direcciones variando los \u00e1ngulos de los servos.</li> <li>Comprender la relaci\u00f3n entre los movimientos de los servomotores y la inclinaci\u00f3n resultante de la placa.</li> <li>Documentar el proceso mec\u00e1nico, electr\u00f3nico y de programaci\u00f3n del sistema.</li> </ul>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#alcance-y-exclusiones","title":"Alcance y Exclusiones","text":"<p>-Incluye:</p> <ul> <li>Montaje mec\u00e1nico con una placa m\u00f3vil y cuatro servos.</li> <li>C\u00f3digo para controlar la inclinaci\u00f3n de la placa en ambos ejes. </li> <li>Pruebas manuales de inclinaci\u00f3n mediante valores programados.</li> <li>Calibraci\u00f3n b\u00e1sica del rango de movimiento de los servos.</li> </ul> <p>-No Incluye:</p>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#procedimiento","title":"Procedimiento","text":""},{"location":"Proyecto%20base%20que%20se%20estabiliza/#diseno-mecanico-del-sistema","title":"Dise\u00f1o Mec\u00e1nico Del Sistema","text":"<p>Se construy\u00f3 una plataforma con dos niveles:</p> <p>1- Placa inferior fija, donde se colocan los servomotores.</p> <p>2- Placa superior m\u00f3vil, unida mediante r\u00f3tulas o uniones articuladas.</p> <p>Cada uno de los dos servomotores est\u00e1 conectado a un punto distinto de la placa m\u00f3vil. Al variar el \u00e1ngulo de los servos, se altera la altura relativa de cada esquina de la plataforma, generando inclinaci\u00f3n en dos ejes.</p> <p>Tambien se incluye una webcam mediante la cual recibimos la imagen del de la parte superior de la plataforma donde es colocada la pelota. El objetivo de esto es que mediante la retroaliemtaci\u00f3n visual recibida por parte de la webcam , el sistema pueda compensar perturbaciones y mantener la pelota en la plataforma sin que se caiga de esta.</p> <p>Especificaciones:</p> <ul> <li> <p>Los servos que ocupamos fueron unos Servomotores Mg996r 15kg de 180\u00ba    Y las siguentes medidas:</p> <p>-Longitud del cable: 30cm, cable de se\u00f1al (amarillo), rojo (alimentaci\u00f3n), marr\u00f3n (masa).</p> <p>-Tama\u00f1o :40.7 * 19.7 * 42.9mm - Por otro lado la plataforma fue realizada con madera mdf de un grosor de 3 mm con un \u00e1rea de 20 * 20 cm. - Por ultimo, se realizo una base en forma de cruz para sostener los servos de forma horizontal, la cual cada parte tenia una longitud aproximada a 14 cm con un ancho de 3.5 cm y un alto de 2 cm, dejando en cada esquina un compartimento para el servo, con las medidas exactas de estos. Ademas de una parte central de 3.5 * 3.5 * 2cm la cual unia estas partes entre si mediante unos tubos los cuales tenian 1cm de diametro y los cuales extruimos 2 cm para que todo pudiese unirse y formar la base.</p> </li> </ul> <p></p> <ul> <li>Por otra parte, se procedi\u00f3 al dise\u00f1o y fabricaci\u00f3n de un par de brazos destinados a acoplarse a los servomotores. Esta configuraci\u00f3n, al conectar los brazos a la plataforma y mantenerlos sujetos a los servos, permiti\u00f3 el correcto proceso de nivelaci\u00f3n de la plataforma.</li> </ul> <p></p>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#programacion-del-codigo","title":"Programaci\u00f3n del c\u00f3digo","text":"<p>Por otro lado y probablemente la parte m\u00e1s importante para que funionara el mecanismo, es el codigo, el cual consistio en 2 partes, el codigo realizado en python mediante Visual Studio.</p> <p>El c\u00f3digo desarrollado en Visual Studio tiene como prop\u00f3sito realizar el procesamiento visual y el control principal del sistema Ball and Plate. Su funci\u00f3n consiste en detectar en tiempo real la posici\u00f3n de una pelota sobre la plataforma y generar las se\u00f1ales de correcci\u00f3n necesarias para mantenerla en equilibrio.</p> <p>Para lograr esto, el programa utiliza una c\u00e1mara conectada al sistema para capturar video en vivo. Mediante t\u00e9cnicas de visi\u00f3n artificial (OpenCV), identifica la pelota a trav\u00e9s de un filtrado por color en el espacio HSV y determina sus coordenadas dentro del cuadro de imagen. Una vez obtenida la posici\u00f3n, el algoritmo calcula el error respecto al centro de la plataforma y aplica un control del tipo PD (Proporcional\u2013Derivativo) para generar una respuesta din\u00e1mica y estable.</p> <p>El resultado de este c\u00e1lculo se traduce en dos \u00e1ngulos de inclinaci\u00f3n (eje X y eje Y), los cuales se env\u00edan de manera continua al microcontrolador ESP32 mediante comunicaci\u00f3n Bluetooth. Finalmente, estos valores ser\u00e1n interpretados por el sistema Arduino/ESP32 para ajustar los servomotores y as\u00ed modificar la inclinaci\u00f3n de la base f\u00edsica. <pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\n\n# = BLUETOOTH =\ndevice_mac = \"7C:9E:BD:70:0A:1E\"   # MISMA MAC DEL ESP32\nport = 1\n\n# =PAR\u00c1METROS SERVOS (2 EJES) =\n# SERVO_X controla inclinaci\u00f3n eje X (izquierda/derecha)\n# SERVO_Y controla inclinaci\u00f3n eje Y (arriba/abajo)\nNEUT_X = 180   # neutro a 180\u00b0\nNEUT_Y = 180   # neutro a 180\u00b0\n\n#  MODO TEST (para exagerar el movimiento) \nTEST_MODE = True   # Cambia a False cuando ya quieras algo m\u00e1s fino\n\nif TEST_MODE:\n    # Mucho m\u00e1s movimiento de servos\n    MAX_SERVO_OFFSET_X = 70.0   # rango de inclinaci\u00f3n en X (grados)\n    MAX_SERVO_OFFSET_Y = 45.0   # rango de inclinaci\u00f3n en Y (grados)\n\n    # Control m\u00e1s agresivo y SIN derivada (m\u00e1s f\u00e1cil ver el sentido)\n    KpX = 2.0\n    KdX = 0.0\n\n    KpY = 2.0\n    KdY = 0.0\nelse:\n    # Valores m\u00e1s tranquilos para uso normal\n    MAX_SERVO_OFFSET_X = 50.0\n    MAX_SERVO_OFFSET_Y = 40.0\n\n    KpX = 0.8\n    KdX = 0.2\n\n    KpY = 0.8\n    KdY = 0.2\n\n# = FLAGS DE ORIENTACI\u00d3N (LOS VAS CAMBIANDO EN VIVO) =\nINVERT_X = False   # lo puedes cambiar con la tecla 'x'\nINVERT_Y = False   # lo puedes cambiar con la tecla 'y'\nSWAP_AXES = False  # si True, intercambia X&lt;-&gt;Y (tecla 's')\n\nalpha = 0.8          # filtro para derivada\nMIN_DT_CMD = 0.015   # 15 ms (~66 Hz m\u00e1x)\n\nlast_cmd_time = 0.0\nlast_time = time.time()\n\nlast_errx = 0.0\nlast_erry = 0.0\ndxf = 0.0\ndyf = 0.0\n\n# Centro calibrado de la plataforma (en p\u00edxeles de la imagen)\ncenterX = None\ncenterY = None\n\n# \u00daltima posici\u00f3n conocida de la pelota (para la tecla 'b')\nlast_ball_x = None\nlast_ball_y = None\n\n# = CONEXI\u00d3N BLUETOOTH =\nsock = None\nprint(\"Intentando conectar al ESP32 por Bluetooth...\", device_mac)\nwhile True:\n    try:\n        sock = bluetooth.BluetoothSocket()\n        sock.settimeout(10)\n        sock.connect((device_mac, port))\n        print(\" Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error de conexi\u00f3n, reintentando:\", e)\n        time.sleep(1)\n\n# = ENVIAR NEUTRO INICIAL A 180\u00b0 EN LOS 2 SERVOS =\ntry:\n    cmd_init = f\"ANG:{NEUT_X},{NEUT_Y}\\n\"\n    sock.send(cmd_init.encode())\n    last_cmd_time = time.time()\n    print(\"Posici\u00f3n inicial 180\u00b0 enviada:\", cmd_init.strip())\nexcept Exception as e:\n    print(\" Error al enviar posici\u00f3n inicial:\", e)\n\n# = C\u00c1MARA (LA QUE VE LA PLATAFORMA) =\n# Cambia 1 a 0 si tu otra c\u00e1mara es la que ve la plataforma\nvideo = cv2.VideoCapture(1)\n\n# =RANGO HSV PARA LA PELOTA (EJEMPLO: NARANJA) =\nLOWER = np.array([10, 150, 120], np.uint8)\nUPPER = np.array([25, 255, 255], np.uint8)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n\nwhile True:\n    ok, frame = video.read()\n    if not ok:\n        break\n\n    # Si la c\u00e1mara te da la imagen al rev\u00e9s y quieres voltearla:\n    # frame = cv2.flip(frame, 1)\n\n    h, w = frame.shape[:2]\n\n    # Si a\u00fan no hay centro calibrado, por defecto usa el centro de la imagen\n    if centerX is None or centerY is None:\n        centerX = w // 2\n        centerY = h // 2\n\n    now = time.time()\n    dt = now - last_time if now &gt; last_time else 0.01\n    send_allowed = (now - last_cmd_time) &gt;= MIN_DT_CMD\n\n    # --- Detecci\u00f3n de pelota por color ---\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask = cv2.inRange(hsv, LOWER, UPPER)\n    mask = cv2.erode(mask, kernel, iterations=2)\n    mask = cv2.dilate(mask, kernel, iterations=2)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    tiene_pelota = False\n\n    if len(contornos) &gt; 0:\n        c = max(contornos, key=cv2.contourArea)\n        (x, y), radio = cv2.minEnclosingCircle(c)\n\n        if radio &gt; 5:  # umbral m\u00ednimo para ruido\n            tiene_pelota = True\n\n            x = int(x)\n            y = int(y)\n            radio = int(radio)\n\n            # Guardamos \u00faltima posici\u00f3n de la pelota\n            last_ball_x = x\n            last_ball_y = y\n\n            # Dibujar pelota\n            cv2.circle(frame, (x, y), radio, (255, 0, 0), 2)\n            cv2.circle(frame, (x, y), 3, (255, 0, 0), -1)\n\n            # Dibujar l\u00edneas del centro calibrado\n            cx = int(centerX)\n            cy = int(centerY)\n            cv2.line(frame, (cx, 0), (cx, h), (0, 255, 255), 1)\n            cv2.line(frame, (0, cy), (w, cy), (0, 255, 255), 1)\n            cv2.circle(frame, (cx, cy), 5, (0, 255, 0), -1)  # centro calibrado\n\n            # Errores normalizados respecto al centro calibrado\n            errx_img = (x - cx) / (w / 2)   # derecha +, izquierda -\n            erry_img = (y - cy) / (h / 2)   # abajo +, arriba -\n\n            # Posible intercambio de ejes\n            if SWAP_AXES:\n                errx_raw = erry_img\n                erry_raw = errx_img\n            else:\n                errx_raw = errx_img\n                erry_raw = erry_img\n\n            # Invertir si hace falta (lo cambias en vivo con 'x' y 'y')\n            if INVERT_X:\n                errx_raw = -errx_raw\n            if INVERT_Y:\n                erry_raw = -erry_raw\n\n            # Mostrar errores crudos para debug\n            cv2.putText(frame, f\"Ex:{errx_raw:+.2f} Ey:{erry_raw:+.2f}\",\n                        (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (255, 255, 255), 2)\n\n            # - Control PD -\n            derx = (errx_raw - last_errx) / dt\n            dery = (erry_raw - last_erry) / dt\n\n            dxf = alpha * dxf + (1 - alpha) * derx\n            dyf = alpha * dyf + (1 - alpha) * dery\n\n            uX = KpX * errx_raw + KdX * dxf\n            uY = KpY * erry_raw + KdY * dyf\n\n            # Limitamos uX, uY a [-1,1]\n            uX = float(np.clip(uX, -1.0, 1.0))\n            uY = float(np.clip(uY, -1.0, 1.0))\n\n            # Offset de servos en grados (cada servo controla un eje)\n            servo_off_X = uX * MAX_SERVO_OFFSET_X\n            servo_off_Y = uY * MAX_SERVO_OFFSET_Y\n\n            # \u00c1ngulos l\u00f3gicos absolutos\n            ang_x = NEUT_X - servo_off_X   # SERVO eje X\n            ang_y = NEUT_Y - servo_off_Y   # SERVO eje Y\n\n            # Limitar a 0..180\n            ang_x = int(np.clip(ang_x, 0, 180))\n            ang_y = int(np.clip(ang_y, 0, 180))\n\n            cv2.putText(frame,\n                        f\"X:{ang_x}  Y:{ang_y}\",\n                        (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0, 255, 255), 2)\n\n            # Enviar comando ANG: (2 servos: X,Y) \n            if send_allowed:\n                try:\n                    cmd = f\"ANG:{ang_x},{ang_y}\\n\"\n                    sock.send(cmd.encode())\n                    # print(\"CMD -&gt;\", cmd.strip())\n                    last_cmd_time = now\n                except Exception as e:\n                    print(\" Error al enviar ANG:\", e)\n\n            last_errx = errx_raw\n            last_erry = erry_raw\n            last_time = now\n\n    if not tiene_pelota:\n        cv2.putText(frame, \"PELOTA NO DETECTADA\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7,\n                    (0, 0, 255), 2)\n        # Si pierdes la pelota, manda NEUTROS \u2192 180\u00b0 en los 2 servos\n        if send_allowed:\n            try:\n                cmd_lost = f\"ANG:{NEUT_X},{NEUT_Y}\\n\"\n                sock.send(cmd_lost.encode())\n                last_cmd_time = now\n                # print(\"CMD LOST-NEUTRO -&gt;\", cmd_lost.strip())\n            except Exception as e:\n                print(\" Error al enviar NEUTRO (sin pelota):\", e)\n\n    # Mostrar estado de flags\n    status = f\"invX:{INVERT_X}  invY:{INVERT_Y}  swap:{SWAP_AXES}  TEST:{TEST_MODE}\"\n    cv2.putText(frame, status, (10, h - 10),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)\n\n    cv2.imshow(\"Ball Balancing Control\", frame)\n    cv2.imshow(\"Mascara\", mask)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        # Tecla 'c' para centrar manualmente (180\u00b0 en ambos)\n        try:\n            cmd_c = f\"ANG:{NEUT_X},{NEUT_Y}\\n\"\n            sock.send(cmd_c.encode())\n            last_cmd_time = time.time()\n            print(\"Comando CENTRO 180\u00b0 enviado.\")\n        except Exception as e:\n            print(\" Error al enviar CENTRO:\", e)\n    elif key == ord('x'):\n        INVERT_X = not INVERT_X\n        print(\"INVERT_X -&gt;\", INVERT_X)\n    elif key == ord('y'):\n        INVERT_Y = not INVERT_Y\n        print(\"INVERT_Y -&gt;\", INVERT_Y)\n    elif key == ord('s'):\n        SWAP_AXES = not SWAP_AXES\n        print(\"SWAP_AXES -&gt;\", SWAP_AXES)\n    elif key == ord('b'):\n        # Calibrar centro con la pelota en el centro f\u00edsico\n        if last_ball_x is not None and last_ball_y is not None:\n            centerX = last_ball_x\n            centerY = last_ball_y\n            print(f\"Centro calibrado en ({centerX}, {centerY})\")\n\nvideo.release()\nsock.close()\ncv2.destroyAllWindows()\n</code></pre></p> <p>El c\u00f3digo de Arduno implementado en el ESP32 tiene como prop\u00f3sito recibir, interpretar y ejecutar los comandos de control enviados desde el programa en Python, con el fin de mover los servomotores que inclinan la plataforma del sistema Ball and Plate. Su funci\u00f3n principal es actuar como la interfaz f\u00edsica entre el algoritmo de control y el mecanismo real.</p> <p>A trav\u00e9s del m\u00f3dulo Bluetooth interno del ESP32, el microcontrolador recibe continuamente mensajes en el formato \u201cANG:x,y\u201d, los cuales representan los \u00e1ngulos l\u00f3gicos de los servomotores para los ejes X y Y. Una vez recibido un comando, el programa lo analiza, lo valida y lo convierte en un \u00e1ngulo f\u00edsico real, tomando en cuenta la inversi\u00f3n mec\u00e1nica de los servos para que los movimientos correspondan correctamente a las direcciones generadas por el controlador.</p> <p>El sistema incorpora una rampa de movimiento suave, dise\u00f1ada para evitar saltos bruscos que puedan generar vibraciones o inestabilidad en la plataforma. Esta rampa ajusta gradualmente la posici\u00f3n de los servos hasta alcanzar el \u00e1ngulo objetivo, mejorando el desempe\u00f1o din\u00e1mico y reduciendo el desgaste mec\u00e1nico. Asimismo, el c\u00f3digo implementa un mecanismo de seguridad que devuelve autom\u00e1ticamente los servos a su posici\u00f3n neutra si no se recibe ning\u00fan comando en un tiempo determinado.</p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n// Buffer para lectura BT no bloqueante \nString btBuffer;\n// Pines de los servos\n// SERVO_X controla eje X\n// SERVO_Y controla eje Y\n#define SERVO_X   21\n#define SERVO_Y   19\n// PWM\nconst uint32_t FREQ_HZ = 50;\nconst uint8_t  RES_BITS = 12;\nconst uint16_t DUTY_MIN = 205;   // ~1.0 ms\nconst uint16_t DUTY_MAX = 410;   // ~2.0 ms\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg){\n  deg = constrain(deg,0,180);\n  return map(deg,0,180,DUTY_MIN,DUTY_MAX);\n}\n// Convierte de \u00e1ngulo l\u00f3gico (0..180) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg){\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  // 0 l\u00f3gico -&gt; 180 f\u00edsico, 180 l\u00f3gico \u2192 0 f\u00edsico\n  return 180 - logicalDeg;\n}\n// Escribe usando grados l\u00f3gicos\nvoid writeServoLogical(int pin, int logicalDeg){\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical){\n  pinMode(pin,OUTPUT);\n  ledcAttach(pin,FREQ_HZ,RES_BITS);   // usa el pin como canal\n  writeServoLogical(pin,initialLogical);\n}\n//  Rango y rampa \nconst int LIM_MIN = 0;\nconst int LIM_MAX = 180;\nconst int PASO_RAMPA = 45;          // tama\u00f1o de paso en rampa\nconst uint32_t DT_RAMP_MS = 2;\nconst uint32_t TIMEOUT_MS = 700;\n// Estado en grados L\u00d3GICOS (arrancan en 180)\nint posX = 180;\nint posY = 180;\nint tgtX = 180;\nint tgtY = 180;\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n// Rampa suave hacia el objetivo\nvoid aplicarRampa(){\n  uint32_t now = millis();\n  if(now - tPrevRamp &lt; DT_RAMP_MS) return;\n  tPrevRamp = now;\n  auto go = [&amp;](int actual,int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n  posX = go(posX, tgtX);\n  posY = go(posY, tgtY);\n  // Escribimos usando grados L\u00d3GICOS, se invierten adentro\n  writeServoLogical(SERVO_X, posX);\n  writeServoLogical(SERVO_Y, posY);\n}\n//  \"ANG:x,y\"\nbool parseAngulos(const String &amp;msg, int &amp;aX, int &amp;aY){\n  if (!msg.startsWith(\"ANG:\")) return false;\n  String data = msg.substring(4);  // despu\u00e9s de \"ANG:\"\n  int c1 = data.indexOf(',');\n  if (c1 &lt; 0) return false;\n  String sX = data.substring(0, c1);\n  String sY = data.substring(c1 + 1);\n  sX.trim();\n  sY.trim();\n  aX = sX.toInt();\n  aY = sY.toInt();\n  return true;\n}\n// SETUP \nvoid setup(){\n  Serial.begin(115200);\n  SerialBT.begin(\"fina\");\n  // Ambos servos arrancan en 180 l\u00f3gico\n  configServo(SERVO_X, posX);\n  configServo(SERVO_Y, posY);\n  Serial.println(\"ESP32 listo (2 servos X/Y, neutro 180\u00b0)\");\n  tLastCmd = millis();\n}\n// LOOP \nvoid loop(){\n  // Lectura Bluetooth no bloqueante \n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();\n    if (c == '\\n') {\n      // Tenemos una l\u00ednea completa en btBuffer\n      String msg = btBuffer;\n      btBuffer = \"\";        // limpiar para el siguiente mensaje\n      msg.trim();\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();\n        if (msg == \"ZERO\") {\n          // Todos a 0 l\u00f3gico (180 f\u00edsico por inversi\u00f3n)\n          tgtX = 0;\n          tgtY = 0;\n          Serial.println(\"Comando ZERO: X/Y \u2192 0 l\u00f3gico (180 f\u00edsico)\");\n        } else {\n          int aX, aY;\n          if (parseAngulos(msg, aX, aY)) {\n            tgtX = constrain(aX, LIM_MIN, LIM_MAX);\n            tgtY = constrain(aY, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; X:%d  Y:%d\\n\", tgtX, tgtY);\n          } else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    } else if (c != '\\r') {\n      // Acumulamos caracteres, ignorando CR\n      btBuffer += c;\n    }\n  }\n  // Si pasa mucho tiempo sin recibir comandos, vuelve al neutro 180\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtX = 180;\n    tgtY = 180;\n  }\n  aplicarRampa();\n  delay(1);\n}\n</code></pre>"},{"location":"Proyecto%20base%20que%20se%20estabiliza/#funcionamiento-de-la-base","title":"Funcionamiento de la base","text":"<p>La primera imagen presentada es la imagen de la camara siendo ejecutada y como captura la plataforma y la pelota en ella.</p> <p></p> <p>Mientas que la segunda imagen es la imagen de la plataforma completa junto con el circuito y la pelota en ella.</p> <p></p> <p>Y para finalizar, subimos a youtube un video con los resultados del mecanismo funionando correctamente.</p> <p>Link: youtube.com/watch?si=ySMpmDCWlPXWW_h-&amp;v=5i9Qri7ijuo&amp;feature=youtu.be</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}